import { body, param, query, validationResult, ValidationChain } from "express-validator";
import { Request, Response, NextFunction } from "express";
import { AppError, BadRequestError } from "./errorHandler";

// Middleware to handle validation results
export const handleValidationErrors = (req: Request, _res: Response, next: NextFunction) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const errorMessages = errors.array().map(err => `${(err as any).path || (err as any).param || 'unknown_field'}: ${err.msg}`).join(', ');
    return next(new BadRequestError(`Validation failed: ${errorMessages}`));
  }
  next();
};

// --- Cart Validators ---
// ... (addItemToCartValidators, removeItemFromCartValidators, updateCartItemQuantityValidators - no changes)
export const addItemToCartValidators: ValidationChain[] = [
  body("id").isString().notEmpty().withMessage("productId (as 'id' in body) must be a non-empty string."), // Client sends 'id' for productId
  body("name").isString().notEmpty().withMessage("Item name must be a non-empty string."),
  body("price").isNumeric().withMessage("Price must be a number.").toFloat(),
  body("quantity").isNumeric().isInt({ min: 1 }).withMessage("Quantity must be an integer greater than 0.").toInt(),
  body("category").isString().notEmpty().withMessage("Category must be a non-empty string."),
  body("imageUrl").optional().isURL().withMessage("Image URL must be a valid URL."),
];

export const removeItemFromCartValidators: ValidationChain[] = [
  param("cartItemId").isString().notEmpty().withMessage("Cart Item ID in path must be a non-empty string."),
];

export const updateCartItemQuantityValidators = [
    param("cartItemId").isString().notEmpty().withMessage("Cart Item ID in path must be a non-empty string."),
    body("quantity").isNumeric().isInt({ min: 0 }).withMessage("Quantity must be an integer >= 0.").toInt(),
];


// --- Item/Rental Item Validators ---
const baseItemFieldsValidators: ValidationChain[] = [
  body("name").trim().notEmpty().withMessage("Item name is required.").isString().withMessage("Item name must be a string."),
  body("category").trim().notEmpty().withMessage("Category is required.").isString().withMessage("Category must be a string."),
  body("description").trim().notEmpty().withMessage("Description is required.").isString().withMessage("Description must be a string."),
  body("price").isFloat({ gt: 0 }).withMessage("Price must be a positive number.").toFloat(),
  body("originalPrice").optional().isFloat({ gt: 0 }).withMessage("Original price must be a positive number.").toFloat(),
  body("discount").optional().isFloat({ min: 0, max: 100 }).withMessage("Discount must be between 0 and 100.").toFloat(),
  body("availability")
    .optional() // Making it optional, service can default it
    .isIn([true, false, "available", "rented", "maintenance"])
    .withMessage("Availability must be a boolean or one of: available, rented, maintenance."),
  body("imageUrl").optional().isURL().withMessage("Image URL must be a valid URL."),
  body("specifications").optional().isObject().withMessage("Specifications must be an object."),
  body("offers").optional().isArray().withMessage("Offers must be an array.")
    .custom((offersArray: any[]) => offersArray.every(offer => typeof offer === 'string'))
    .withMessage("Each offer must be a string."),
  body("ratings").optional().isFloat({ min: 0, max: 5 }).withMessage("Ratings must be a number between 0 and 5.").toFloat(),
  body("rentalType").optional().isIn(["short-term", "long-term", "event"]).withMessage("Invalid rentalType."),
  body("ownerContactInfo").optional().isString().trim().withMessage("Owner contact info must be a string."),
  body("stock").optional().isInt({ min: 0 }).withMessage("Stock must be a non-negative integer.").toInt(),
];

export const createItemValidators: ValidationChain[] = [
  body("id").optional().isString().trim().notEmpty().withMessage("ID, if provided, must be a non-empty string."), // ID can be auto-generated by service
  ...baseItemFieldsValidators,
];

export const updateItemValidators: ValidationChain[] = [
  param("id").isString().notEmpty().withMessage("Item ID in path is required."),
  // Category (partition key) should be in query for PUT to identify the item correctly
  query("category").isString().notEmpty().withMessage("Category query parameter (partitionKey) is required for update."),
  // Fields for update are optional, so use .optional() where appropriate in baseItemFieldsValidators if they were all required before
  // For simplicity, we reuse baseItemFieldsValidators, but a dedicated update set might make some fields explicitly optional
  ...baseItemFieldsValidators.map(validator => validator.optional()), // Make all fields optional for update
  body("name").optional().trim().notEmpty().withMessage("Item name is required.").isString().withMessage("Item name must be a string."), // Overriding some to ensure they are still validated if present
  body("category").optional().trim().notEmpty().withMessage("Category is required.").isString().withMessage("Category cannot be updated via this route, use specific migration if needed."), // Category should not be updated easily
  body("description").optional().trim().notEmpty().withMessage("Description is required.").isString().withMessage("Description must be a string."),
  body("price").optional().isFloat({ gt: 0 }).withMessage("Price must be a positive number.").toFloat(),
];

export const getItemByIdValidators: ValidationChain[] = [
  param("id").isString().notEmpty().withMessage("Item ID in path must be a non-empty string."),
  query("category").isString().notEmpty().withMessage("Category query parameter (partitionKey) is required."),
];

export const filterItemsValidators: ValidationChain[] = [
  param("categoryName").isString().notEmpty().withMessage("Category name in path must be a non-empty string."),
  query("search").optional().isString().withMessage("Search query must be a string."),
  query("minPrice").optional().isNumeric().withMessage("Minimum price must be a number.").toFloat(),
  query("maxPrice").optional().isNumeric().withMessage("Maximum price must be a number.").toFloat(),
  query("ratings").optional().isNumeric().isFloat({ min: 0, max: 5 }).withMessage("Ratings must be a number between 0 and 5.").toFloat(),
  query("rentalType").optional().isIn(["short-term", "long-term", "event"]).withMessage("Invalid rentalType."),
];